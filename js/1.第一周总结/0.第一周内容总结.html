第一部分：关于git
1、把一个普通的文件夹，变成git可以管理的本地仓库  git init

2、 git add . /-A
    git commit -m"注释的内容"
    git push origin master

3、添加远程通道
    git remote add  teacher 地址

4、如何查看你链接了哪些远程通道？
    git remote -v;

5、更新讲义
    1）fork 将老师远程仓库的内容放在自己的远程仓库中
    2）将自己远程仓库的内容放在本地仓库中，放在本地仓库中进入文件夹例如：JavaScript201606，
        git clone https://github.com/自己的名字/JavaScript201606.git
        此时该仓库已于远程仓库进行了连接，可用git remote -v进行查看
        origin  https://github.com/zj135808/JavaScript201606.git (fetch)
        其中origin是本地仓库与自己远程仓库连接的名称
    3）连接老师的远程仓库
        git remote add zhufeng https://github.com/zhufengpeixun/JavaScript201606.git
        其中珠峰是本地仓库与老师远程仓库连接的名称
        删除一个远程地址：例如删除zhunfeng的连接远程仓库地址：git remote rm zhufeng
    4）假如老师课件有更新，可更新本地仓库与老师远程仓库的通道
        git remote update zhufeng
    5）更新通过之后，需要将通道中最新的内容拉取到本地仓库中
        git pull zhufeng master
    6）此时本地仓库的内容已经更新，但自己的远程仓库还没有更新，所以需要将最新的内容更新到远程仓库中
        git add .
        git commit -m""
        git pull origin master
        git push origin master

6、如何上传作业
    1.自己的本地仓库添加内容
    2.git add .
    3.git commit -m"注释"
    4.git pull origin master
    5.git push origin master
    6.远程github上，点击new pull request按钮
    7.点击 create pull request
    这里可以添加标题和内容

*********************************************************************************************
*********************************************************************************************

第二部分：预解释
1、 概念：在当前作用域下，在JS代码执行之前，浏览器会对带var和function的进行提前声明或者定义
    声明：告诉浏览器有这么一个变量，但是没有赋值，没复制拿到的是undefined
    定义：对已经声明过的这个变量进行赋值
    关于变量和函数预解释阶段的不同
    带var：只声明不定义
    带function：声明与定义

2、关于预解释的无节操：
    1）自执行函数不需要预解释，当代码执行到它的时候：声明+定义+调用 同步完成
    2）已经声明过的变量，不需要重新声明，只需要重新赋值
    3）对于带var的，我们只对等号左边，进行声明，不运行等号右边的（即只声明不定义）
    4）if条件语句，无论条件是否成立，都会进行预解释
        注：在if条件语句中不要定义函数，因为各大浏览器对if语句的预解释不同，很容易出错
    5）return 返回值不进行预解释，return下面的语句虽然不执行，但是会进行预解释
        自执行函数、等号右边、return返回值不进行预解释
        if语句，return下面的语句进行预解释
        预解释不重声明，但是会重定义

*********************************************************************************************
*********************************************************************************************

第三部分：关于作用域
1、全局作用域：当浏览器加载html页面的时候，会形成一个供JS代码执行的环境，在这个全局作用域下，所有的全局变量都是window上的全局属性，所有的全局函数，都是window上的全局方法
   私有作用域：

2、作用域链：当函数执行的时候，形成一个私有作用域，查看作用域中的这个变量是否为私有变量：
    1）如果是私有变量：这个函数中的所有此变量，跟外面没有任何关系；
    2）如果不是私有变量：
        a）如果是获取：往上级作用域进行查找，如果找到，弹出，找不到继续往上级作用域进行查找，最终一直找到window，如果还没有，报错
        b）如果是设置：往上级作用域进行查找，如果找到，重新赋值，找不到继续往上级作用域进行查找，最终一直找到window，如果还没有，它就是window上的全局属性

*********************************************************************************************
*********************************************************************************************

第四部分：关于内存和内存释放
1、JS中内存： 堆内存 和 栈内存
    栈内存：提供了一个供JS代码执行的环境
    环境：全局环境，私有环境
    堆内存：存放时引用数据类型的值： 对象：存的对象的属性名和属性值；  函数：把函数体中的JS代码作为字符串存在这个空间中

2、堆内存释放：只要堆内存被变量占用，就无法释放
    解决措施:  变量名=null    即：让变量名等于空指针，当浏览器空闲的时候，就会把指向空诊治的变量收回，浏览器的这种回收机制，叫做垃圾回收机制

3、栈内存释放：
    1）全局作用域：当浏览器加载完html页面的时候，就形成一个全局作用域，只有关闭页面，才能释放，如果不关闭页面，全局作用域下的所有变量和内容都无法得到释放
我们唯一能做的就是减少全局变量
    2）私有作用域：当函数执行的之后，形成一个私有作用域，一般情况下，当函数执行完成的时候就被释放，有两种情况不会被释放：
        a）如果私有函数中有东西被函数外面的变量或者其它元素占用的时候，此函数不能释放
        b）不立即释放：这个函数执行完成的时候，会返回一个函数，被返回的这个函数还需要再执行一次，等返回的函数执行完成，所有的函数才能释放

*********************************************************************************************
*********************************************************************************************

第五部分：关于this
1、关于this
    1）当触发一个元素身上的事件，执行对应的函数的时候，函数中的this，指向当前这个元素
    2）当函数执行的之后，点前面是谁，this就是谁
    3）自执行函数中的this永远都是window
    4）在构造函数中，this指向当前实例
    5）call()，apply(),bind()
    6）回调函数中this一般指向window

*********************************************************************************************
*********************************************************************************************

第六部分：面向对象的理解
1、对象由两部分构成：属性 和 方法
2、面向对象的特点：
    1）封装：对于相同功能的代码，放在一个函数中，以后再用到此功能，只需要调用即可，无需再重写，避免大量冗余代码
        专业话说：低耦合，高内聚
    2）继承：子类继承父类原有的属性和方法
        类：'Object','Function','Number','String','Array','RepExp','Date'.....
    3）多态：重载和重写
        重载：在JS中不存在严格意义上的重载，但是JS有类似重载的功能：同一个函数，传不同的参数，可以实现不同的功能
        重写：子类可以重写父类的属性和方法

*********************************************************************************************
*********************************************************************************************

第七部分：JS中的设计模式：
1、单例模式：本质就是普通对象
    1）单例模式：把描述同一事物的属性和方法，放在同一个命名空间下，避免了变量名冲突的问题
        命名空间：浏览器开辟了一个堆内存，给它分配的名字person1就是命名空间
    2）单例模式的优缺点：
        优点：1）可以实现模块化开发  2）避免了属性名相同，以及变量名相同的冲突问题
        缺点：1）传统的手工作业模式，开发效率低，并且造成大量冗余代码
    注：
        a）单例模式就是简单的模块化开发
        b）它可以实现本模块间的相互调用：this.属性名
        c）可以实现模块之间的相互调用： 模块名.属性名

2、工厂模式：本质就是函数的封装
    1）工厂模式的思想：
        a）引进一批原材料-------var obj={};
        b）对原材料进行加工------给对象添加一些私有的属性和方法
        c）输出原材料------输出对象   return obj;

3、构造函数模式： 实例 、 类
    1）构造函数的目的：为了自定义一个类，并且可以创建一个实例
    2）构造函数的缺点：对于相同的功能，却不相等，可用原型prototype解决
注：
    a）构造函数中放的都是私有的属性和方法
    b）就是实例和类在打交道
    c）在创建一个实例的时候，如果不需要传参，小括号可以省略
    d）构造函数this，用于指向当前实例
    e）在构造函数中，实例只跟this.xxx有关系，和变量没有任何关系
    f）构造函数中，系统默认会为我们返回一个对象，人回我们手动返回的话：
        return 基本数据类型，不会造成任何影响，实例还有它的属性和方法
        return 引用数据类型，会影响系统返回的对象，实例就没有它以前的属性和方法了
    不建议手动返回对象

4、原型模式：  实例 、 类 、 原型
    1）原型模式基础：
        a）每一个函数数据类型（类、普通函数）上都天生自带一个属性，叫做prototype（原型），它是一个对象
        b）prototype这个原型上，天生自带一个属性，叫做constructor，指向当前函数（类）本身
        c）每个对象（实例，普通对象，prototype）上，都天生自带一个属性，叫做__proto__，它指向当前实例所属的类的原型
        注：自己创建的对象上没有constructor这个属性
    2）原型链查找机制：比如要朝着f1.x==>对象.属性名
        a）在自己的私有属性上查找，如果找到，那么这个属性就是私有属性
        b）如果没有找到，通过__proto__去所属类的原型上进行查找，因为原型上放的都是公有的属性和方法，所以，如果找到，这个属性就是公有的
        c）如果没有找到，通过__proto__一层层往上找，最终找到基类object.prototype上，如果还没有，undefined


5、构造函数模式与工厂模式的区别：
    1）在调用的时候
        构造函数  new Person()
        工厂模式   person()
    2）在函数体内的区别
        构造函数：系统自动创建一个对象，等我们给对象加工完成后，系统自动输出该对象
        工厂模式：手动创建对象，等我们给对象加工完成后，手动输出对象

6、几个反应：重中之重；
    1）一看到函数名首字母大写：构造函数--》构造函数中放的都是私有的属性和方法；
    2）一看A.prototype：原型--》原型上放的都是公有的属性和方法；
    3）一看到A.prototype={}-->这是自己创建的原型对象，上面一定没有constructor,这个实例就不能进行类的细分；
    4）一看到__proto__：这是进行原型链的查找；

*********************************************************************************************
*********************************************************************************************

第八部分：原型
1、为什么学习原型：
    1）可以知道系统内置类上的所有属性和方法；方便自己拓展学习
    2）可以给系统内置类上扩展一些公有的方法和属性；

2、批量添加A这个类的公有属性和方法；
    A.prototype={
        constructor:A,
        show1:function(){
            alert(123)
        },
        show2:function(){},
        show3:function(){},
    };

3、关于系统内置类不可以批量操作，这是系统内置类的自我保护机制；但是，可以一个一个操作；

4、关于链式操作
为什么能进行链式操作？因为每个方法调用后必须得有一个返回值，并且，这个返回值一定得是数组，才能继续通过点调用数组的其他方法；

5、关于对象属性的判断--返回值：boolean值
    1）in 用来判断这个属性是否是对象上的属性：公有属性和私有属性；
    2）hasOwnProperty() 用来判断是否为私有属性
    3）需求：如果判断是否为公有属性？hasPubproperty

6、用到的函数
obj.isPrototypeOf(obj2) 判断obj是否在obj2的原型链上；返回的也是boolean值；
var obj2=Object.create(obj) 作用：把obj作为obj2的原型；

*********************************************************************************************
*********************************************************************************************

第九部分：继承
继承：子类可以继承父类原有的属性和方法，但是当子类添加私有属性和方法的时候不对父类造成影响

1、原型链继承：把父类的 私有+公有 的属性和方法都作为子类公有的属性
    核心：不是把父类 私有+公有 的属性克隆一份一模一样的给子类的公有，它是通过__proto__建立了和子类之间的原型链，当子类的实例需要使用父类的属性和方法的时候，可以通过__proto__一级级的找上去，去使用

2、call继承：把父类私有的属性和方法给了子类私有的属性和方法
    核心：相当于把父类的私有的属性和方法克隆了一份一模一样的给子类的私有属性和方法

3、冒充继承：把父类 私有+公有 的属性都作为子类私有的属性

4、混合继承1：call继承 + 原型链继承
    call继承：把父类私有的作为子类私有的
    原型链继承：把父类 私有+公有 作为公有的
    问题：父类私有的，在子类 私有+公有 两个地方都存在

5、混合继承2：call继承 + 拷贝继承
    call继承：把父类私有的作为自己私有的
    拷贝继承：通过for in循环，把父类公有的属性和方法克隆了一份一模一样的给子类公有的

6、寄生式继承：
    call继承：把父类私有的作为自己私有的
    object.create()思想：
        1）创建一个空类
        2）给空类的原型添加了父类原型的地址：（相当于把父类原型上的公有属性和方法，给了空类原型上）
        3）子类的原型上添加空类的实例：（这样，子类就可以通过__proto__去找父类公有的属性和方法，但是不受父类私有属性的影响）

*********************************************************************************************
*********************************************************************************************

第十部分：其它的
1、函数包含：定义和调用
    定义3步骤：
        a）开辟一个空间地址
        b）把函数体中所有JS代码作为字符串存在这个空间中
        c）把空间地址赋值给函数名
    函数调用3步骤：
        a）对形参赋值
        b）预解释
        c）JS代码从上到下的执行

2、带var和不带var的区别：
    带var：1）会进行预解释 2）如果是全局变量，它还是window的全局属性
    不带var：1）不会进行预解释  2）如果是设置：往上级作用域进行查找，如果找到，重新赋值，找不到继续往上级作用域进行查找，最终一直找到window，如果还没有，它就是window上的全局属性

3、私有变量有且只有两种：
    1）函数中带var的
    2）形参

4、闭包的作用：
    1）防止变量名冲突
    2）在闭包中对全局变量重新赋值，并且不影响全局变量
    3）可以通过window.xx改变全局变量
    4）闭包可以用来封装，可以通过window.xxx=函数名

5、函数当作表达式赋值给变量时注意事项：
    当函数作为表达式赋值给一个变量的时候，是按照变量的预解释机制进行预解释的
    这个变量名，就相当于函数名，虽然不能在上面调用，但是可以在函数赋值后进行调用

6、回调函数需要考虑的四点
    1）当函数表达式作为参数传给另一个函数的时候，就是回调函数callback;
    2)callback被调用多少次取决于条件
    3）callback中的this，一般都是window,callback如果改变this指向--call
    4）callback如何传参 --1)有call的时候从第二个参数开始传2）直接传；
    5）回调函数中有返回值吗?

