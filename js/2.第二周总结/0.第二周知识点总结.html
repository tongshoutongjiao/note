第一部分：函数与对象：

1、原型基础：重中之重！！！
    1）每一个函数数据类型（类，普通函数），都天生自带一个属性，叫prototype，它是一个对象
    2）prototype这个对象上天生自带一个属性constructor,他指向当前所属类；
    3）每个对象（实例，普通对象，prototype）上都带一个属性__proto__,他指向当前实例所属类的原型；
2、根据上面的原型基础，可得出：
    1） 每个类都是Function这个类的实例
    2） Object是所有实例的基类
    原因：每个实例，通过__proto__都能先找到距离自己最近的类，但是所有的实例都能通过__proto__最终找到object这个基类
3、Function中的原型
    1）Function.prototype它是一个函数数据类型，它是一个匿名函数，但是它的功能与普通对象的原型一模一样
4、Object和Funciton的关系：
    1）Function是Object这个基类的爹
    2）Object.prototype 是 Function.prototype 的爹
5、函数的三种角色：
    1）普通函数：形成一个私有作用域--形参赋值--预解释--JS代码执行环境--作用域的释放
    2）类：实例，原型（prototype），__proto__原型链，constructor：指向的是所属的类，私有属性和公有属性
    3）对象：当函数是一个对象的时候，它其实就跟普通的对象没有区别（普通对象的特征：属性和方法）
    注：函数的三种角色之前互相不干扰

***************************************************************************************************
***************************************************************************************************

第二部分：call ，apply ， bind 的区别：

1、call和和apply的执行步骤
    1）把call点前面的函数中的this关键字变成call的第一个参数
    2）把call点前面的函数执行；
2、bind的执行过程
    bind和call在传参的时候是一样的；（改变this指向，参1，参2。。。）
    bind预解析机制：1.首先改变bind中的this关键字，同时把bind点前面的函数中的形参传值，然后返回一个修改过的函数；我们可以用变量去接受这个返回的函数
3、call和apply的区别：
    1）首先它们都是通过第一个参数改变this指向的
    2）call是从第二个参数，一个个的传参，传递给call前面的函数的形参（也是对形参从左到右一个个的赋值）
    3）apply是从第二个参数开始，以一个数组的形式传参，传递给apply前面的函数的形参（也是对形参从左到右一个个的赋值）
4、一般情况下，我们开发JS都用非严格模式
    非严格模式下
        fn.call();  //->this->window
        fn.call(null);  //->this->window
        fn.call(undefined);  //->this->window
    严格模式下，给call或apply第一个参数传谁this就是谁，不传就是undefined
        fn.call(); //->undefined
        fn.call(null); //->null
        fn.call(undefined);  //->undefined

***************************************************************************************************
***************************************************************************************************

第三部分：浏览器异常捕获

1、try catch 一般用于进行浏览器兼容处理

try{ //执行的是浏览器支持并且能正常执行的js语句
    alert(a);
}catch(e){
    // 当try里面的语句不能正常执行的时候，走的是catch里面的语句
    // console.log(e);  // 打印出错误原因
    throw new Error(e);  //throw new Error 可以把错误内容以红色字体打印出来，同时不再执行后面的语句
}finally{
    //这里的语句无论try中是否执行，这里都会执行，因此一般不写finally
}

**************************************************************************************************
**************************************************************************************************

第四部分：数据绑定及DOM回流与映射

1、字符串拼接
    缺点：相当于把页面中的内容拿出来，跟我们已经拼接好的字符串str再进行字符串拼接；最后拿到新拼接好的字符串把他转化为标签，重新放入页面中；所以，以前页面中元素身上的事件就都没有了；
    优点：只引发一次DOM回流
    注：工作中用的最多的就是字符串拼接；
2、动态创建
    动态创建，循环中每次插入---缺点：每循环一次，就会DOM回流一次，耗性能；
    优点：可以保留以前元素身上的事件
3、动态创建+文档碎片document.createDocumentFragment();
    优点：只引发一次DOM回流，而且可以保留原来元素身上的事件；
4、DOM映射：1.HTML页面结构中的标签（HTML）  2.获取到的元素集合（js）
    1）当页面中的HTML标签发生变化的时候，我们不需要重新获取，JS中的元素集合就会对应的发生变化；
    2）当我们用JS操作页面中的内容的时候，页面中的标签也会相应的发生变化；
    他们两个互相影响；
5、DOM回流：
    1）当页面中的HTML结构发生改变（增加，删除元素，位置发生改变...），浏览器都需要重新的计算一遍最新的DOM结构，重新的对当前的页面进行渲染

**************************************************************************************************
************************************************************************************************

第六部分：json

1、JSON，他是一种数据格式；用来进行前后台数据交互
2、对象的属性名上，如果有""号，他就是json;反之就是普通对象；使用方式是一样的；
3、JSON是window上的一个对象，里面包含两个方法
    1）JSON.parse(jsonStr);jsonStr:json格式的字符串 功能：把JSON格式的字符串转成JSON格式的数据；
    2）JSON.stringify(jsonObj) 把JSON格式的数据转成JSON格式的字符串；

************************************************************************************************
************************************************************************************************

第五部分：ajax

1、ajax
    1）创建一个ajax对象
    2）打开一个地址，3个参数（'get','data.txt',false）
    3）响应请求 xml.readyState xml.status
    4）发送请求 xml.send();
2、JS的异步编程：同步和异步
    同步：当前项目干不完，不会开始下一项
    异步：当前项目干不完，不等他，继续执行后面的项目，等后面的项目都执行完成时候，再返回来执行当前项目；

************************************************************************************************
************************************************************************************************

第七部分：其它

1、关于类数组与数组的那些事
    类数组通过call可以使用数组中的常用方法
2、类数组转为数组可以使用slice方式
3、对类数组排序
    1）将类数组转为数组
    2）对数组进行排序
    3）将排好序的数组插入到页面中